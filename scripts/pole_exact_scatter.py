#!/usr/bin/env python3
"""
Plot ε-sensitivity at exact det(J)=0 and report zero-norm rates.

Loads the dataset JSON and a list of trainer results JSON files, aligns the
test split, extracts samples with exact or near-exact |detJ|=0, and plots the
distribution of predicted ||Δθ|| per model.

Also prints, per model, the fraction of zero-norm predictions among exact-pole
test samples (for TR, non-REAL tags are recorded as 0.0 in saved predictions,
so this approximates tag-driven non-REAL behavior at poles).

Usage:
  python scripts/pole_exact_scatter.py \
    --dataset data/rr_ik_dataset_exact.json \
    --results runs/ik_eps_noclip_1e-2/results_rat_eps.json \
              runs/ik_eps_noclip_1e-3/results_rat_eps.json \
              runs/ik_eps_noclip_1e-4/results_rat_eps.json \
              runs/ik_tr_basic/results_tr_rat.json \
              runs/ik_tr_full/results_tr_rat.json \
    --labels  "ε=1e-2 (no clip)" "ε=1e-3 (no clip)" "ε=1e-4 (no clip)" "TR Basic" "TR Full" \
    --out results/robotics/figures/pole_exact_scatter.png
"""

import argparse
import json
import math
import os
from typing import Any, Dict, List, Tuple

import numpy as np


def _split_counts(meta: Dict[str, Any], n_total: int) -> Tuple[int, int]:
    if meta.get("stratified_by_detj") and isinstance(meta.get("train_bucket_counts"), list):
        n_train = int(sum(meta.get("train_bucket_counts")))
        return n_train, n_total - n_train
    return int(0.8 * n_total), n_total - int(0.8 * n_total)


def _load_dataset(path: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
    with open(path, "r") as fh:
        ds = json.load(fh)
    return ds.get("samples", []), ds.get("metadata", {})


def _load_results(path: str) -> Dict[str, Any]:
    with open(path, "r") as fh:
        return json.load(fh)


def compute_near_pole_indices(
    samples: List[Dict[str, Any]], n_train: int, thresh: float
) -> List[int]:
    idxs = []
    t = max(0.0, float(thresh))
    for i, s in enumerate(samples[n_train:]):
        try:
            dj = abs(float(s.get("det_J")))
        except Exception:
            # fallback to |sin(theta2)| for RR
            th2 = float(s.get("theta2", 0.0))
            dj = abs(math.sin(th2))
        if dj <= t:
            idxs.append(n_train + i)
    return idxs


def main():
    ap = argparse.ArgumentParser(
        description="Plot ε-sensitivity at exact det(J)=0 and report zero-norm rates"
    )
    ap.add_argument(
        "--dataset", required=True, help="Path to dataset JSON (generated by rr_ik_dataset.py)"
    )
    ap.add_argument(
        "--results", nargs="+", required=True, help="List of trainer results JSON files to include"
    )
    ap.add_argument(
        "--labels", nargs="*", default=None, help="Optional labels for each results file"
    )
    ap.add_argument(
        "--out",
        default="results/robotics/figures/pole_exact_scatter.png",
        help="Output figure path",
    )
    ap.add_argument(
        "--detj_thresh",
        type=float,
        default=0.0,
        help="Select samples with |detJ| ≤ threshold (default: 0 for exact poles)",
    )
    args = ap.parse_args()

    samples, meta = _load_dataset(args.dataset)
    n_total = len(samples)
    n_train, n_test = _split_counts(meta, n_total)
    near_idxs = compute_near_pole_indices(samples, n_train, args.detj_thresh)
    if not near_idxs:
        if args.detj_thresh <= 0.0:
            print(
                "No exact det(J)=0 samples found in test split; consider using --detj_thresh 1e-5 for B0."
            )
        else:
            print(f"No near-pole samples found with |detJ| ≤ {args.detj_thresh}.")
        return

    # Build arrays of norms per model
    norms_per_model: List[List[float]] = []
    labels: List[str] = []
    for i, rp in enumerate(args.results):
        try:
            res = _load_results(rp)
        except Exception as e:
            print(f"Warning: failed to load {rp}: {e}")
            continue
        preds = res.get("test_metrics", {}).get("predictions", [])
        if not preds:
            print(f"Warning: no predictions in {rp}")
            continue
        # Align to test split
        test_preds = preds  # saved predictions are aligned to test split only
        # Extract norms on exact pole indices within test
        norms: List[float] = []
        for gi in near_idxs:
            ti = gi - n_train  # local index in test split
            if ti < 0 or ti >= len(test_preds):
                continue
            p = test_preds[ti]
            try:
                if isinstance(p, list) and len(p) >= 2:
                    val = math.sqrt((float(p[0]) ** 2) + (float(p[1]) ** 2))
                else:
                    val = abs(float(p[0])) if isinstance(p, list) and p else float(p)
            except Exception:
                val = 0.0
            norms.append(val)
        norms_per_model.append(norms)
        if args.labels and i < len(args.labels):
            labels.append(args.labels[i])
        else:
            # Fallback label from file name
            labels.append(os.path.basename(os.path.dirname(rp)))

    # Print zero-norm rates as a proxy for non-REAL tags in TR runs
    for lab, norms in zip(labels, norms_per_model):
        if not norms:
            continue
        zeros = sum(1 for v in norms if v == 0.0)
        rate = 100.0 * zeros / len(norms)
        region = f"|detJ|≤{args.detj_thresh:g}" if args.detj_thresh > 0.0 else "detJ=0"
        print(f"{lab:24s}  near-pole count={len(norms):4d} ({region})  zero-norm%={rate:6.2f}")

    # Plot
    try:
        import matplotlib.pyplot as plt
        import numpy as np
    except Exception as e:
        print(f"matplotlib not available: {e}. Skipping scatter plot.")
        return
    os.makedirs(os.path.dirname(args.out), exist_ok=True)

    plt.figure(figsize=(7.0, 3.0), dpi=150)
    x = []
    y = []
    c = []
    for i, norms in enumerate(norms_per_model):
        if not norms:
            continue
        xs = np.random.uniform(i - 0.25, i + 0.25, size=len(norms))
        x.append(xs)
        y.append(np.array(norms))
        c.append(np.full_like(xs, i))
    if x:
        X = np.concatenate(x)
        Y = np.concatenate(y)
        plt.scatter(X, Y, s=12, alpha=0.6)
        plt.xticks(range(len(labels)), labels, rotation=20)
        ylabel = (
            f"||Δθ|| at |det J| ≤ {args.detj_thresh:g}"
            if args.detj_thresh > 0
            else "||Δθ|| at det(J)=0"
        )
        plt.ylabel(ylabel)
        plt.title("Near-pole ε-sensitivity vs TR")
        plt.yscale("log")
        plt.tight_layout()
        plt.savefig(args.out)
        plt.close()
        print(f"Saved scatter to {args.out}")
    else:
        print("No points to plot (empty norms)")


if __name__ == "__main__":
    main()
